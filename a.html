<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GitHub Tetris Contributions</title>
  <style>
    body {
      margin: 0;
      background: #0d1117; /* GitHub dark background */
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    canvas {
      border: 2px solid #30363d;
      border-radius: 6px;
      background-color: #161b22; /* GitHub graph container */
    }
  </style>
</head>
<body>
    <div align="center" style="max-width: 420px; margin: 20px auto; padding: 15px; border: 2px solid #00ff99; border-radius: 12px; background: #000; box-shadow: 0 0 18px #00ff99;">
  <h3 style="color: #00ff99; font-family: 'Courier New', monospace; font-weight: bold; text-shadow: 0 0 12px #00ff99;">
    &gt; Top Languages
  </h3>
  <img src="https://github-readme-stats.vercel.app/api/top-langs/?username=0xHI50kA&layout=compact&bg_color=000000&title_color=00ff99&text_color=00ff99&icon_color=00ff99&border_color=00ff99&hide_border=false&card_width=400"
       alt="Top Languages" width="380" height="200" style="border-radius: 10px; box-shadow: 0 0 10px #00ff99;" />
</div>

<br>

<div align="center" style="max-width: 420px; margin: 20px auto; padding: 15px; border: 2px dashed #00ff99; border-radius: 12px; background: radial-gradient(circle at center, rgba(0, 255, 153, 0.05) 0%, rgba(0, 0, 0, 0.95) 100%); box-shadow: 0 0 25px #00ff99;">
  <h3 style="color: #00ff99; font-family: 'Courier New', monospace; font-weight: bold; text-shadow: 0 0 12px #00ff99;">
    $ github-stats --hacker-mode
  </h3>
  <img src="https://github-readme-stats.vercel.app/api?username=0xHI50kA&show_icons=true&bg_color=000000&title_color=00ff99&text_color=00ff99&icon_color=00ff99&border_color=00ff99&hide_border=false&card_width=400"
       alt="GitHub Stats" width="380" height="200" style="border-radius: 10px; box-shadow: 0 0 10px #00ff99;" />
</div>

  <canvas id="tetrisCanvas"></canvas>
  <script>
    const canvas = document.getElementById("tetrisCanvas");
    const ctx = canvas.getContext("2d");

    const cellSize = 14;  // cell including gap
    const blockSize = 10; // block size inside cell
    const columns = 53;   // GitHub graph width
    const rows = 7;       // GitHub graph rows
    canvas.width = columns * cellSize;
    canvas.height = rows * cellSize;

    const colors = ["#161b22", "#0e4429", "#006d32", "#26a641", "#39d353"];

    let settled = Array.from({ length: rows }, () => Array(columns).fill(null));
    let fallingBlocks = [];
    let clearingRows = []; // rows currently being cleared

    function createBlock() {
      return {
        x: Math.floor(Math.random() * columns),
        y: 0,
        color: colors[Math.floor(Math.random() * (colors.length - 1)) + 1]
      };
    }

    function drawGrid() {
      ctx.fillStyle = "#161b22"; 
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#1d2228"; // faint grey for empty cells
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < columns; x++) {
          ctx.fillRect(
            x * cellSize + (cellSize - blockSize) / 2,
            y * cellSize + (cellSize - blockSize) / 2,
            blockSize,
            blockSize
          );
        }
      }
    }

    function drawBlock(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(
        x * cellSize + (cellSize - blockSize) / 2,
        y * cellSize + (cellSize - blockSize) / 2,
        blockSize,
        blockSize
      );
    }

    function startRowClearAnimation(row) {
      clearingRows.push({
        y: row,
        progress: 0
      });
    }

    function processClearingRows() {
      for (let i = 0; i < clearingRows.length; i++) {
        const row = clearingRows[i];
        const step = Math.floor(row.progress);

        if (step < columns) {
          // Clear one cell at a time from left to right
          settled[row.y][step] = null;
          row.progress += 0.5; // animation speed
        } else {
          // Row fully cleared, shift above rows down
          for (let yy = row.y; yy > 0; yy--) {
            settled[yy] = [...settled[yy - 1]];
          }
          settled[0] = Array(columns).fill(null);
          clearingRows.splice(i, 1);
          i--;
        }
      }
    }

    function detectFullRows() {
      for (let y = rows - 1; y >= 0; y--) {
        if (settled[y].every(cell => cell !== null) &&
            !clearingRows.find(r => r.y === y)) {
          startRowClearAnimation(y);
        }
      }
    }

    function update() {
      drawGrid();

      // Draw settled blocks
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < columns; x++) {
          if (settled[y][x]) {
            drawBlock(x, y, settled[y][x]);
          }
        }
      }

      // Update falling blocks
      fallingBlocks.forEach(block => {
        block.y += 0.1; // speed
        const gridY = Math.floor(block.y);

        if (gridY >= rows - 1 || settled[gridY + 1][block.x]) {
          settled[gridY][block.x] = block.color;
          block.settled = true;
        }

        drawBlock(block.x, Math.floor(block.y), block.color);
      });

      fallingBlocks = fallingBlocks.filter(b => !b.settled);

      if (Math.random() < 0.15) {
        fallingBlocks.push(createBlock());
      }

      processClearingRows();
      detectFullRows();

      requestAnimationFrame(update);
    }

    update();
  </script>
</body>
</html>
